library(clustermq)
library(dplyr)
library(magrittr)

# `model_code`: String of the .stan file
# `data`: List object to be passed to Stan. In most cases this will come from
#         the configuration generated by Covidestim.
# `seedVal`: The seed for the optimizer
f <- function(model_code, data) {

  # `optimizing` comes from `rstan`, assumption is that `rstan` has already
  # been loaded.
  optimizing(
    # Compile the model on the cluster. Don't save the .dso, this guarantees
    # that it will not be reused.
    object = stan_model(save_dso=F, model_code=model_code),
    data = data,
    algorithm = "BFGS",
    iter = 1e4, 
    verbose = T,
    as_vector = F,
  )
}

fMultiple <- function(
  model_code,
  data,
  tries   = 15,
  iter    = 6e3,
  timeout = 5*60
) {
  rstan_options(auto_write = T)
  model <- stan_model(model_code = model_code)
  
  runOptimizerWithSeed <- function(i) {
    startTime <- Sys.time()

    rstan::optimizing(
      object    = model,
      data      = data,
      algorithm = "BFGS",
      iter      = iter,
      as_vector = FALSE # Otherwise you get a sloppy list structure
    ) -> result

    endTime <- Sys.time()

    message(glue::glue(
      'Finished try #{i} in {dt} with exit code {ec}',
      dt = prettyunits::pretty_dt(endTime - startTime),
      ec = result$return_code
    ));

    result
  }

  # This function will return NULL when there is a timeout
  runOptimizerWithSeedInTime <- function(i, timeout)
    tryCatch(
      R.utils::withTimeout(runOptimizerWithSeed(i), timeout = timeout),
      error = function(c) {
        message(glue::glue('Abandoned try #{i} due to timeout'))

        NULL
      }
    )

  result <- NULL

  # Return the first time we get a non-obviously-bad result from BFGS, to save
  # time.
  for (i in 1:tries) {
    r <- runOptimizerWithSeedInTime(i, timeout)
    
    # Return code of 0 indicates success for `rstan::optimizing`. This is just
    # a standard UNIX return code b/c `rstan::optimizing` calls into CmdStan.
    # 
    # Timed-out runs return NULL.
    #
    # In theory the log posterior could be infinite (likely, -Infinity), which
    # wouldn't be valid but would technically be the maximum value. Exclude
    # runs which have these values.
    if (!is.null(r) && (r$return_code[1] == 0) && !is.infinite(r$value) && (r$value > -3000)) {
      message("[#{i}]: Good result!")
      result <- r # Commit the result as the final result
      break
    }
  }

  if (is.null(result)) # Branch only occurs if no good result was I.D.'d.
    stop("All BFGS runs timed out or failed or had Inf log-posteriors!")

  result
}

# Use ClusterMQ to connect to the cluster, compile the model, and run it.
# This function can easily be modified to perform various experiments. See
# the docs: `?clustermq::Q`. Worker logs will be found in `~/`.
run <- function(f, tests, codePath, jobs_per_worker = 4, time_per_run = 12) {
  result <- Q(
    f,
    data = tests$config,
    const = list(model_code = read_file(codePath)),
    job_size = jobs_per_worker,
    log_worker = T,
    pkgs = 'rstan',
    fail_on_error = F,
    template = list(time = jobs_per_worker * time_per_run)
  )

  mutate(tests, result = result)
}

states <- c("New York", "Florida", "New Hampshire", "Colorado")

map(
 states,
 ~mutate(testset, region = ., d = list(getInputs(.)))
) %>% bind_rows %>% as_tibble %>% getConfigs -> tests

test_results4 <- run(fMultiple, tests, "../covidestim/inst/stan/stan_program_default.stan", jobs_per_worker = 12, time_per_run = 30)
